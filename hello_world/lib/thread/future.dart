import 'dart:async';

/**
 你可以把 Dart 的线程想象成一个 while 循环，这个循环一直不停地从两个“任务队列”里取任务来执行。

    1.微任务队列（Microtask Queue）：
        优先级最高，事件循环每一轮会优先清空这个队列里的所有任务。
        通常用于一些非常紧急的内部任务，例如在状态更新后、UI绘制前需要做的些事情。
        我们日常开发很少直接操作它。

    2.事件队列（Event Queue）：
        1）我们最常打交道的队列。所有的外部事件、Future、I/O操作、用户手势（如点击）等，
          都会被包装成一个事件项（Event Item）放入这个队列。
        2）事件循环会按先进先出（FIFO） 的顺序处理它们。

    重点： 只要事件循环没有被阻塞（即某个任务执行时间过长），它就能及时地处理用户点击、绘制UI等事件，应用就会感觉很流畅。
 */

///Future 并不是一个新的线程，它只是事件队列的一个“高级管理者”。
///它是什么？
///   一个 Future 对象代表一个异步操作的最终结果（完成或失败）。
///   它承诺在未来某个时间点给你一个答案。
///它如何工作？
///   当你创建一个 Future（比如执行网络请求），
///   这个耗时操作本身可能会由Dart运行时或操作系统派发到其他线程（如I/O线程）去执行，
///   但它的回调函数（.then() 或 await 之后的代码）依然是被放回事件队列等待执行。
///核心作用： 避免回调地狱（Callback Hell），用同步代码的写法来写异步操作。
///
///
///Future 的重点与难点：
///   重点： 它用于I/O密集型操作，如网络请求、文件读写、数据库查询等。
///         这些操作大部分时间是在等待，Dart可以利用这个等待时间去处理其他事件。
///   难点/误区：
///         Future 并不适合做CPU密集型计算！
///         如果你在 Future 里写一个复杂的数学计算（比如循环10亿次），
///         这个计算过程依然会霸占事件循环，导致页面卡顿。因为计算本身是在事件队列的任务里执行的。
///         当你需要执行真正重量级的、长时间运行的CPU计算时，Future 就无能为力了。这时就需要 Isolate。

void testFuture() {
  print('程序开始: ${DateTime.now()}');

  // 模拟一个耗时2秒的网络请求，返回一个Future
  fetchUserOrder()
      .then((order) {
        print('订单是: $order');
      })
      .catchError((error) {
        print('出错: $error');
      });

  // 这段代码不会等待Future完成，会立即执行
  print('程序结束: ${DateTime.now()}');
}

// 这是一个返回Future的异步函数
Future<String> fetchUserOrder() {
  // 使用Future.delayed模拟耗时操作
  return Future.delayed(Duration(seconds: 2), () {
    // 这个回调函数在2秒后被放入事件队列，等待事件循环执行
    return '超大杯珍珠奶茶 ${DateTime.now()}';
    // throw Exception('网络连接失败！'); // 可以取消注释测试错误情况
  });
}

/** 输出结果
程序开始: 2025-09-11 15:48:17.796
程序结束: 2025-09-11 15:48:17.796
订单是: 超大杯珍珠奶茶 2025-09-11 15:48:19.798
 */
